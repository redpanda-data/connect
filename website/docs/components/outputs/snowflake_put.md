---
title: snowflake_put
type: output
status: experimental
categories: ["Services"]
---

<!--
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the contents of:
     lib/output/snowflake_put.go
-->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::caution EXPERIMENTAL
This component is experimental and therefore subject to change or removal outside of major version releases.
:::
Sends messages to Snowflake stages and, optionally, calls Snowpipe to load this data into one or more tables.


<Tabs defaultValue="common" values={[
  { label: 'Common', value: 'common', },
  { label: 'Advanced', value: 'advanced', },
]}>

<TabItem value="common">

```yml
# Common config fields, showing default values
output:
  label: ""
  snowflake_put:
    account: ""
    region: ""
    cloud: ""
    user: ""
    password: ""
    private_key_file: ""
    private_key_pass: ""
    role: ""
    database: ""
    warehouse: ""
    schema: ""
    stage: ""
    path: ""
    compression: AUTO
    snowpipe: ""
    batching:
      count: 0
      byte_size: 0
      period: ""
      check: ""
    max_in_flight: 1
```

</TabItem>
<TabItem value="advanced">

```yml
# All config fields, showing default values
output:
  label: ""
  snowflake_put:
    account: ""
    region: ""
    cloud: ""
    user: ""
    password: ""
    private_key_file: ""
    private_key_pass: ""
    role: ""
    database: ""
    warehouse: ""
    schema: ""
    stage: ""
    path: ""
    upload_parallel_threads: 4
    compression: AUTO
    snowpipe: ""
    batching:
      count: 0
      byte_size: 0
      period: ""
      check: ""
      processors: []
    max_in_flight: 1
```

</TabItem>
</Tabs>

In order to use a different stage and / or Snowpipe for each message, you can use function interpolations as described
[here](/docs/configuration/interpolation#bloblang-queries). When using batching, messages are grouped by the calculated
stage and Snowpipe and are streamed to individual files in their corresponding stage and, optionally, a Snowpipe
`insertFiles` REST API call will be made for each individual file.

### Credentials

Two authentication mechanisms are supported:
- User/password
- Key Pair Authentication

#### User/password

This is a basic authentication mechanism which allows you to PUT data into a stage. However, it is not compatible with
Snowpipe.

#### Key Pair Authentication

This authentication mechanism allows Snowpipe functionality, but it does require configuring an SSH Private Key
beforehand. Please consult the [documentation](https://docs.snowflake.com/en/user-guide/key-pair-auth.html#configuring-key-pair-authentication)
for details on how to set it up and assign the Public Key to your user.

Note that the Snowflake documentation suggests using this command:

```shell
openssl genrsa 2048 | openssl pkcs8 -topk8 -inform PEM -out rsa_key.p8
```

to generate an encrypted SSH private key. However, in this case, it uses an encryption algorithm called
`pbeWithMD5AndDES-CBC`, which part of the PKCS#5 v1.5, which is considered insecure. Due to this, Benthos does not
support it and, if you wish to use password-protected keys directly, you must use PKCS#5 v2.0 to encrypt them. One way
of achieving this is to use the following command:

```shell
openssl genrsa 2048 | openssl pkcs8 -topk8 -v2 des3 -inform PEM -out rsa_key.p8
```

Alternatively, you can re-encrypt an existing key using this command:

```shell
openssl pkcs8 -in rsa_key_original.p8 -topk8 -v2 des3 -out rsa_key.p8
```

Please consult this [documentation](https://linux.die.net/man/1/pkcs8) for details.

### Batching

It's common to want to upload messages to Snowflake as batched archives. The easiest way to do this is to batch your
messages at the output level and join the batch of messages with an
[`archive`](/docs/components/processors/archive) and/or [`compress`](/docs/components/processors/compress)
processor.

For the optimal batch size, please consult the Snowflake [documentation](https://docs.snowflake.com/en/user-guide/data-load-considerations-prepare.html).

### Snowpipe

Given a table called `BENTHOS_TBL` with one column of type `variant`:

```sql
CREATE OR REPLACE TABLE BENTHOS_DB.PUBLIC.BENTHOS_TBL(RECORD variant)
```

and the following `BENTHOS_PIPE` Snowpipe:

```sql
CREATE OR REPLACE PIPE BENTHOS_DB.PUBLIC.BENTHOS_PIPE AUTO_INGEST = FALSE AS COPY INTO BENTHOS_DB.PUBLIC.BENTHOS_TBL FROM (SELECT * FROM @%BENTHOS_TBL) FILE_FORMAT = (TYPE = JSON COMPRESSION = AUTO)
```

you can configure Benthos to use the implicit table stage `@%BENTHOS_TBL` as the `stage` and
`BENTHOS_PIPE` as the `snowpipe`. In this case, you must set `compression` to `AUTO` and, if
using message batching, you'll need to configure an [`archive`](/docs/components/processors/archive) processor
with the `concatenate` format. Since the `compression` is set to `AUTO`, the
[gosnowflake](https://github.com/snowflakedb/gosnowflake) client library will compress the messages automatically so you
don't need to add a [`compress`](/docs/components/processors/compress) processor for message batches.

If you add `STRIP_OUTER_ARRAY = TRUE` in your Snowpipe `FILE_FORMAT`
definition, then you must use `json_array` instead of `concatenate` as the archive processor format.

Note: Only Snowpipes with `FILE_FORMAT` `TYPE` `JSON` are currently supported.

### Snowpipe Troubleshooting

Snowpipe [provides](https://docs.snowflake.com/en/user-guide/data-load-snowpipe-rest-apis.html) the `insertReport`
and `loadHistoryScan` REST API endpoints which can be used to get information about recent Snowpipe calls. In
order to query them, you'll first need to generate a valid JWT token for your Snowflake account. There are two methods
for doing so:
- Using the `snowsql` [utility](https://docs.snowflake.com/en/user-guide/snowsql.html):

```shell
snowsql --private-key-path rsa_key.p8 --generate-jwt -a <account> -u <user>
```

- Using the Python `jwt-generator` [utility](https://docs.snowflake.com/en/developer-guide/sql-api/guide.html#using-key-pair-authentication):

```shell
python3 jwt-generator.py --private_key_file_path=rsa_key.p8 --account=<account> --user=<user>
```

Once you successfully generate a JWT token and store it into the `JWT_TOKEN` environment variable, then you can,
for example, query the `insertReport` endpoint using `curl`:

```shell
curl -H "Authorization: Bearer ${JWT_TOKEN}" "https://<account>.snowflakecomputing.com/v1/data/pipes/<database>.<schema>.<snowpipe>/insertReport"
```

If you need to pass in a valid `requestId` to any of these Snowpipe REST API endpoints, you can enable debug
logging as described [here](/docs/components/logger/about) and Benthos will print the RequestIDs that it sends to
Snowpipe. They match the name of the file that is placed in the stage.


## Performance

This output benefits from sending multiple messages in flight in parallel for
improved performance. You can tune the max number of in flight messages with the
field `max_in_flight`.

This output benefits from sending messages as a batch for improved performance.
Batches can be formed at both the input and output level. You can find out more
[in this doc](/docs/configuration/batching).

## Examples

<Tabs defaultValue="No compression" values={[
{ label: 'No compression', value: 'No compression', },
{ label: 'Automatic compression', value: 'Automatic compression', },
{ label: 'DEFLATE compression', value: 'DEFLATE compression', },
{ label: 'RAW_DEFLATE compression', value: 'RAW_DEFLATE compression', },
]}>

<TabItem value="No compression">

Upload concatenated messages into a .json file to a table stage without calling Snowpipe.

```yaml
output:
  snowflake_put:
    account: benthos
    user: test@benthos.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: BENTHOS_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    path: benthos
    stage: "@%BENTHOS_TBL"
    upload_parallel_threads: 4
    compression: NONE
    batching:
      count: 10
      period: 3s
      processors:
        - archive:
            format: concatenate
```

</TabItem>
<TabItem value="Automatic compression">

Upload concatenated messages compressed automatically into a .gz archive file to a table stage without calling Snowpipe.

```yaml
output:
  snowflake_put:
    account: benthos
    user: test@benthos.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: BENTHOS_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    path: benthos
    stage: "@%BENTHOS_TBL"
    upload_parallel_threads: 4
    compression: AUTO
    batching:
      count: 10
      period: 3s
      processors:
        - archive:
            format: concatenate
```

</TabItem>
<TabItem value="DEFLATE compression">

Upload concatenated messages compressed into a .deflate archive file to a table stage and call Snowpipe to load them into a table.

```yaml
output:
  snowflake_put:
    account: benthos
    user: test@benthos.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: BENTHOS_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    path: benthos
    stage: "@%BENTHOS_TBL"
    upload_parallel_threads: 4
    compression: DEFLATE
    snowpipe: BENTHOS_PIPE
    batching:
      count: 10
      period: 3s
      processors:
        - archive:
            format: concatenate
        - compress:
            algorithm: zlib
```

</TabItem>
<TabItem value="RAW_DEFLATE compression">

Upload concatenated messages compressed into a .rawdeflate archive file to a table stage and call Snowpipe to load them into a table.

```yaml
output:
  snowflake_put:
    account: benthos
    user: test@benthos.dev
    private_key_file: path_to_ssh_key.pem
    role: ACCOUNTADMIN
    database: BENTHOS_DB
    warehouse: COMPUTE_WH
    schema: PUBLIC
    path: benthos
    stage: "@%BENTHOS_TBL"
    upload_parallel_threads: 4
    compression: RAW_DEFLATE
    snowpipe: BENTHOS_PIPE
    batching:
      count: 10
      period: 3s
      processors:
        - archive:
            format: concatenate
        - compress:
            algorithm: flate
```

</TabItem>
</Tabs>

## Fields

### `account`

Account name, which is the same as the Account Identifier
as described [here](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#where-are-account-identifiers-used).
However, when using an [Account Locator](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier),
the Account Identifier is formatted as `<account_locator>.<region_id>.<cloud>` and this field needs to be
populated using the `<account_locator>` part.


Type: `string`  

### `region`

Optional region field which needs to be populated when using
an [Account Locator](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier)
and it must be set to the `<region_id>` part of the Account Identifier
(`<account_locator>.<region_id>.<cloud>`).


Type: `string`  

```yml
# Examples

region: us-west-2
```

### `cloud`

Optional cloud platform field which needs to be populated
when using an [Account Locator](https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier)
and it must be set to the `<cloud>` part of the Account Identifier
(`<account_locator>.<region_id>.<cloud>`).


Type: `string`  

```yml
# Examples

cloud: aws

cloud: gcp

cloud: azure
```

### `user`

Username.


Type: `string`  

### `password`

An optional password.


Type: `string`  

### `private_key_file`

The path to a file containing the private SSH key.


Type: `string`  

### `private_key_pass`

An optional private SSH key passphrase.


Type: `string`  

### `role`

Role.


Type: `string`  

### `database`

Database.


Type: `string`  

### `warehouse`

Warehouse.


Type: `string`  

### `schema`

Schema.


Type: `string`  

### `stage`

Stage name. Use either one of the
[supported](https://docs.snowflake.com/en/user-guide/data-load-local-file-system-create-stage.html) stage types.
This field supports [interpolation functions](/docs/configuration/interpolation#bloblang-queries).


Type: `string`  

### `path`

Stage path.


Type: `string`  

### `upload_parallel_threads`

Specifies the number of threads to use for uploading files.


Type: `int`  
Default: `4`  

### `compression`

Compression type.


Type: `string`  
Default: `"AUTO"`  

| Option | Summary |
|---|---|
| `AUTO` | Compression (gzip) is applied automatically by the output and messages must contain plain-text JSON. |
| `DEFLATE` | Messages must be pre-compressed using the zlib algorithm (with zlib header, RFC1950). |
| `GZIP` | Messages must be pre-compressed using the gzip algorithm. |
| `NONE` | No compression is applied and messages must contain plain-text JSON. |
| `RAW_DEFLATE` | Messages must be pre-compressed using the flate algorithm (without header, RFC1951). |


### `snowpipe`

An optional Snowpipe name. Use the `<snowpipe>` part from `<database>.<schema>.<snowpipe>`.
This field supports [interpolation functions](/docs/configuration/interpolation#bloblang-queries).


Type: `string`  

### `batching`

Allows you to configure a [batching policy](/docs/configuration/batching).


Type: `object`  

```yml
# Examples

batching:
  byte_size: 5000
  count: 0
  period: 1s

batching:
  count: 10
  period: 1s

batching:
  check: this.contains("END BATCH")
  count: 0
  period: 1m
```

### `batching.count`

A number of messages at which the batch should be flushed. If `0` disables count based batching.


Type: `int`  
Default: `0`  

### `batching.byte_size`

An amount of bytes at which the batch should be flushed. If `0` disables size based batching.


Type: `int`  
Default: `0`  

### `batching.period`

A period in which an incomplete batch should be flushed regardless of its size.


Type: `string`  
Default: `""`  

```yml
# Examples

period: 1s

period: 1m

period: 500ms
```

### `batching.check`

A [Bloblang query](/docs/guides/bloblang/about/) that should return a boolean value indicating whether a message should end a batch.


Type: `string`  
Default: `""`  

```yml
# Examples

check: this.type == "end_of_transaction"
```

### `batching.processors`

A list of [processors](/docs/components/processors/about) to apply to a batch as it is flushed. This allows you to aggregate and archive the batch however you see fit. Please note that all resulting messages are flushed as a single batch, therefore splitting the batch into smaller batches using these processors is a no-op.


Type: `array`  

```yml
# Examples

processors:
  - archive:
      format: concatenate

processors:
  - archive:
      format: lines

processors:
  - archive:
      format: json_array
```

### `max_in_flight`

The maximum number of messages to have in flight at a given time. Increase this to improve throughput.


Type: `int`  
Default: `1`  


