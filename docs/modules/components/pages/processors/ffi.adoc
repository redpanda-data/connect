= ffi
:type: processor
:status: experimental



////
     THIS FILE IS AUTOGENERATED!

     To make changes, edit the corresponding source file under:

     https://github.com/redpanda-data/connect/tree/main/internal/impl/<provider>.

     And:

     https://github.com/redpanda-data/connect/tree/main/cmd/tools/docs_gen/templates/plugin.adoc.tmpl
////

// Â© 2024 Redpanda Data Inc.


component_type_dropdown::[]


Invoke a function within a shared library as a processing step.

```yml
# Config fields, showing default values
label: ""
ffi:
  library_path: libbar.6.so # No default (required)
  function_name: MyExternCFunction # No default (required)
  args_mapping: root = [42, now().ts_unix_nano(), content()] # No default (required)
  signature:
    return:
      type: "" # No default (required)
    parameters: [] # No default (required)
```

A processor that allows for dlopen'ing (or platform equivalent) and invoking functions dynamically at runtime. The result from this processor is an array, where the first element is the return type if not void, and then each `out` parameter in parameter order.

== Examples

[tabs]
======
Call a libc function::
+
--

This is an example of loading libc.so and calling a function on linux.

```yaml
pipeline:
  processors:
    - ffi:
        library_path: libc.6.so
        function_name: memcmp
        args_mapping: 'root = ["foo", "bar", 3]'
        signature:
          return:
            type: int32
          parameters:
            - type: byte*
            - type: byte*
            - type: int64
```

--
======

== Fields

=== `library_path`

The path to the shared library (.so, .dylib or .dll) file to load dynamically.


*Type*: `string`


```yml
# Examples

library_path: libbar.6.so

library_path: libfoo.dylib
```

=== `function_name`

The name of the function to load from the shared library.


*Type*: `string`


```yml
# Examples

function_name: MyExternCFunction
```

=== `args_mapping`

The bloblang expression that returns an array of arguments to pass into the foreign function.


*Type*: `string`


```yml
# Examples

args_mapping: root = [42, now().ts_unix_nano(), content()]
```

=== `signature`

The signature of the function.


*Type*: `object`


=== `signature.return`

The configuration for the function's result.


*Type*: `object`


=== `signature.return.type`

The data type of function's return value


*Type*: `string`


|===
| Option | Summary

| `int32`
| A 32 bit signed integer is returned
| `int64`
| A 64 bit signed integer is returned
| `void`
| The function returns nothing

|===

=== `signature.parameters`

The parameters of the function.


*Type*: `array`


=== `signature.parameters[].type`

The data type of the parameter.


*Type*: `string`


|===
| Option | Summary

| `byte*`
| A pointer to a byte array is provided as an argument. Note this byte array cannot be referenced once the function returns. `args_mapping` must return a byte array or string type for this argument, and the parameter in C for this should be `void*`.
| `int32`
| A 32 bit signed integer is provided as an argument
| `int64`
| A 64 bit signed integer is provided as an argument

|===

=== `signature.parameters[].out`

If the parameter provided is an 'out' parameter, meaning if the function mutates the value, and the resulting value should be returned. This is only valid for pointer types.


*Type*: `bool`

*Default*: `false`


