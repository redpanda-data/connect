= Bloblang Functions
:description: A list of Bloblang functions.


////
     THIS FILE IS AUTOGENERATED!

     To make changes please edit the contents of:

     https://github.com/redpanda-data/connect/tree/main/cmd/tools/docs_gen/templates/bloblang_functions.adoc.tmpl
////

// Â© 2024 Redpanda Data Inc.


Functions can be placed anywhere and allow you to extract information from your environment, generate values, or access data from the underlying message being mapped:

```coffeescript
root.doc.id = uuid_v4()
root.doc.received_at = now()
root.doc.host = hostname()
```

Functions support both named and nameless style arguments:

```coffeescript
root.values_one = range(start: 0, stop: this.max, step: 2)
root.values_two = range(0, this.max, 2)
```

== General

=== `bytes`

Creates a zero-initialized byte array of specified length. Use this to allocate fixed-size byte buffers for binary data manipulation or to generate padding.

==== Parameters

- *`length`* &lt;integer&gt; The size of the resulting byte array.  

==== Examples


```coffeescript
root.data = bytes(5)
```

Create a buffer for binary operations.

```coffeescript
root.header = bytes(16)
root.payload = content()
```

=== `counter`

[CAUTION]
====
This function is experimental and therefore breaking changes could be made to it outside of major version releases.
====
Generates an incrementing sequence of integers starting from a minimum value (default 1). Each counter instance maintains its own independent state across message processing. When the maximum value is reached, the counter automatically resets to the minimum.

==== Parameters

- *`min`* &lt;query expression, default `1`&gt; The starting value of the counter. This is the first value yielded. Evaluated once when the mapping is initialized.  
- *`max`* &lt;query expression, default `9223372036854775807`&gt; The maximum value before the counter resets to min. Evaluated once when the mapping is initialized.  
- *`set`* &lt;(optional) query expression&gt; An optional query that controls counter behavior: when it resolves to a non-negative integer, the counter is set to that value; when it resolves to `null`, the counter is read without incrementing; when it resolves to a deletion, the counter resets to min; otherwise the counter increments normally.  

==== Examples


Generate sequential IDs for each message.

```coffeescript
root.id = counter()

# In:  {}
# Out: {"id":1}

# In:  {}
# Out: {"id":2}
```

Use a custom range for the counter.

```coffeescript
root.batch_num = counter(min: 100, max: 200)

# In:  {}
# Out: {"batch_num":100}

# In:  {}
# Out: {"batch_num":101}
```

Increment a counter multiple times within a single mapping using a named map.

```coffeescript

map increment {
  root = counter()
}

root.first_id = null.apply("increment")
root.second_id = null.apply("increment")


# In:  {}
# Out: {"first_id":1,"second_id":2}

# In:  {}
# Out: {"first_id":3,"second_id":4}
```

Conditionally reset a counter based on input data.

```coffeescript
root.streak = counter(set: if this.status != "success" { 0 })

# In:  {"status":"success"}
# Out: {"streak":1}

# In:  {"status":"success"}
# Out: {"streak":2}

# In:  {"status":"failure"}
# Out: {"streak":0}

# In:  {"status":"success"}
# Out: {"streak":1}
```

Peek at the current counter value without incrementing by using null in the set parameter.

```coffeescript
root.count = counter(set: if this.peek { null })

# In:  {"peek":false}
# Out: {"count":1}

# In:  {"peek":false}
# Out: {"count":2}

# In:  {"peek":true}
# Out: {"count":2}

# In:  {"peek":false}
# Out: {"count":3}
```

=== `deleted`

Returns a deletion marker that removes the target field or message. When applied to root, the entire message is dropped while still being acknowledged as successfully processed. Use this to filter data or conditionally remove fields.

==== Examples


```coffeescript
root = this
root.bar = deleted()

# In:  {"bar":"bar_value","baz":"baz_value","foo":"foo value"}
# Out: {"baz":"baz_value","foo":"foo value"}
```

Filter array elements by returning deleted for unwanted items.

```coffeescript
root.new_nums = this.nums.map_each(num -> if num < 10 { deleted() } else { num - 10 })

# In:  {"nums":[3,11,4,17]}
# Out: {"new_nums":[1,7]}
```

=== `ksuid`

Generates a K-Sortable Unique Identifier with built-in timestamp ordering. Use this for distributed unique IDs that sort chronologically and remain collision-resistant without coordination between generators.

==== Examples


```coffeescript
root.id = ksuid()
```

Create sortable event IDs for logging.

```coffeescript
root.event = {
  "id": ksuid(),
  "type": this.event_type,
  "data": this.payload
}
```

=== `nanoid`

Generates a URL-safe unique identifier using Nano ID. Use this for compact, URL-friendly IDs with good collision resistance. Customize the length (default 21) or provide a custom alphabet for specific character requirements.

==== Parameters

- *`length`* &lt;(optional) integer&gt; An optional length.  
- *`alphabet`* &lt;(optional) string&gt; An optional custom alphabet to use for generating IDs. When specified the field `length` must also be present.  

==== Examples


```coffeescript
root.id = nanoid()
```

Generate a longer ID for additional uniqueness.

```coffeescript
root.id = nanoid(54)
```

Use a custom alphabet for domain-specific IDs.

```coffeescript
root.id = nanoid(54, "abcde")
```

=== `pi`

Returns the value of the mathematical constant Pi.

==== Examples


```coffeescript
root.radians = this.degrees * (pi() / 180)

# In:  {"degrees":45}
# Out: {"radians":0.7853981633974483}
```

```coffeescript
root.degrees = this.radians * (180 / pi())

# In:  {"radians":0.78540}
# Out: {"degrees":45.00010522957486}
```

=== `random_int`


Generates a pseudo-random non-negative 64-bit integer. Use this for creating random IDs, sampling data, or generating test values. Provide a seed for reproducible randomness, or use a dynamic seed like `timestamp_unix_nano()` for unique values per mapping instance.

Optional `min` and `max` parameters constrain the output range (both inclusive). For dynamic ranges based on message data, use the modulo operator instead: `random_int() % dynamic_max + dynamic_min`.

==== Parameters

- *`seed`* &lt;query expression, default `{"Value":0}`&gt; A seed to use, if a query is provided it will only be resolved once during the lifetime of the mapping.  
- *`min`* &lt;integer, default `0`&gt; The minimum value the random generated number will have. The default value is 0.  
- *`max`* &lt;integer, default `9223372036854775806`&gt; The maximum value the random generated number will have. The default value is 9223372036854775806 (math.MaxInt64 - 1).  

==== Examples


```coffeescript
root.first = random_int()
root.second = random_int(1)
root.third = random_int(max:20)
root.fourth = random_int(min:10, max:20)
root.fifth = random_int(timestamp_unix_nano(), 5, 20)
root.sixth = random_int(seed:timestamp_unix_nano(), max:20)

```

Use a dynamic seed for unique random values per mapping instance.

```coffeescript
root.random_id = random_int(timestamp_unix_nano())
root.sample_percent = random_int(seed: timestamp_unix_nano(), min: 0, max: 100)
```

=== `range`

Creates an array of integers from start (inclusive) to stop (exclusive) with an optional step. Use this to generate sequences for iteration, indexing, or creating numbered lists.

==== Parameters

- *`start`* &lt;integer&gt; The start value.  
- *`stop`* &lt;integer&gt; The stop value.  
- *`step`* &lt;integer, default `1`&gt; The step value.  

==== Examples


```coffeescript
root.a = range(0, 10)
root.b = range(start: 0, stop: this.max, step: 2) # Using named params
root.c = range(0, -this.max, -2)

# In:  {"max":10}
# Out: {"a":[0,1,2,3,4,5,6,7,8,9],"b":[0,2,4,6,8],"c":[0,-2,-4,-6,-8]}
```

Generate a sequence for batch processing.

```coffeescript
root.pages = range(0, this.total_items, 100).map_each(offset -> {
  "offset": offset,
  "limit": 100
})

# In:  {"total_items":250}
# Out: {"pages":[{"limit":100,"offset":0},{"limit":100,"offset":100}]}
```

=== `snowflake_id`

Generates a unique, time-ordered Snowflake ID. Snowflake IDs are 64-bit integers that encode timestamp, node ID, and sequence information, making them ideal for distributed systems where sortable unique identifiers are needed. Returns a string representation of the ID.

==== Parameters

- *`node_id`* &lt;integer, default `1`&gt; Optional node identifier (0-1023) to distinguish IDs generated by different machines in a distributed system. Defaults to 1.  

==== Examples


Generate a unique Snowflake ID for each message

```coffeescript
root.id = snowflake_id()
root.payload = this
```

Generate Snowflake IDs with different node IDs for multi-datacenter deployments

```coffeescript
root.id = snowflake_id(42)
root.data = this
```

=== `throw`

Immediately fails the mapping with a custom error message. Use this to halt processing when data validation fails or required fields are missing, causing the message to be routed to error handlers.

==== Parameters

- *`why`* &lt;string&gt; A string explanation for why an error was thrown, this will be added to the resulting error message.  

==== Examples


```coffeescript
root.doc.type = match {
  this.exists("header.id") => "foo"
  this.exists("body.data") => "bar"
  _ => throw("unknown type")
}
root.doc.contents = (this.body.content | this.thing.body)

# In:  {"header":{"id":"first"},"thing":{"body":"hello world"}}
# Out: {"doc":{"contents":"hello world","type":"foo"}}

# In:  {"nothing":"matches"}
# Out: Error("failed assignment (line 1): unknown type")
```

Validate required fields before processing.

```coffeescript
root = if this.exists("user_id") {
  this
} else {
  throw("missing required field: user_id")
}

# In:  {"user_id":123,"name":"alice"}
# Out: {"name":"alice","user_id":123}

# In:  {"name":"bob"}
# Out: Error("failed assignment (line 1): missing required field: user_id")
```

=== `ulid`

[CAUTION]
====
This function is experimental and therefore breaking changes could be made to it outside of major version releases.
====
Generates a Universally Unique Lexicographically Sortable Identifier (ULID). ULIDs are 128-bit identifiers that are sortable by creation time, URL-safe, and case-insensitive. They consist of a 48-bit timestamp (millisecond precision) and 80 bits of randomness, making them ideal for distributed systems that need time-ordered unique IDs without coordination.

==== Parameters

- *`encoding`* &lt;string, default `"crockford"`&gt; Encoding format for the ULID. "crockford" produces 26-character Base32 strings (recommended). "hex" produces 32-character hexadecimal strings.  
- *`random_source`* &lt;string, default `"secure_random"`&gt; Randomness source: "secure_random" uses cryptographically secure random (recommended for production), "fast_random" uses faster but non-secure random (only for non-sensitive testing).  

==== Examples


Generate time-sortable IDs for distributed message ordering

```coffeescript
root.message_id = ulid()
root.timestamp = now()
root.data = this
```

Generate hex-encoded ULIDs for systems that prefer hexadecimal format

```coffeescript
root.id = ulid("hex")
```

=== `uuid_v4`

Generates a random RFC-4122 version 4 UUID. Use this for creating unique identifiers that don't reveal timing information or require ordering. Each invocation produces a new globally unique ID.

==== Examples


```coffeescript
root.id = uuid_v4()
```

Add unique request IDs for tracing.

```coffeescript
root = this
root.request_id = uuid_v4()
```

=== `uuid_v7`

Generates a time-ordered UUID version 7 with millisecond timestamp precision. Use this for sortable unique identifiers that maintain chronological ordering, ideal for database keys or event IDs. Optionally specify a custom timestamp.

==== Parameters

- *`time`* &lt;(optional) timestamp&gt; An optional timestamp to use for the time ordered portion of the UUID.  

==== Examples


```coffeescript
root.id = uuid_v7()
```

Generate a UUID with a specific timestamp for backdating events.

```coffeescript
root.id = uuid_v7(now().ts_sub_iso8601("PT1M"))
```

== Message Info

=== `batch_index`

Returns the zero-based index of the current message within its batch. Use this to conditionally process messages based on their position, or to create sequential identifiers within a batch.

==== Examples


```coffeescript
root = if batch_index() > 0 { deleted() }
```

Create a unique identifier combining batch position with timestamp.

```coffeescript
root.id = "%v-%v".format(timestamp_unix(), batch_index())
```

=== `batch_size`

Returns the total number of messages in the current batch. Use this to determine batch boundaries or compute relative positions.

==== Examples


```coffeescript
root.total = batch_size()
```

Check if processing the last message in a batch.

```coffeescript
root.is_last = batch_index() == batch_size() - 1
```

=== `content`

Returns the raw message payload as bytes, regardless of the current mapping context. Use this to access the original message when working within nested contexts, or to store the entire message as a field.

==== Examples


```coffeescript
root.doc = content().string()

# In:  {"foo":"bar"}
# Out: {"doc":"{\"foo\":\"bar\"}"}
```

Preserve original message while adding metadata.

```coffeescript
root.original = content().string()
root.processed_by = "ai"

# In:  {"foo":"bar"}
# Out: {"original":"{\"foo\":\"bar\"}","processed_by":"ai"}
```

=== `error`

Returns the error message string if the message has failed processing, otherwise `null`. Use this in error handling pipelines to log or route failed messages based on their error details.

==== Examples


```coffeescript
root.doc.error = error()
```

Route messages to different outputs based on error presence.

```coffeescript
root = this
root.error_msg = error()
root.has_error = error() != null
```

=== `error_source_label`

Returns the user-defined label of the component that caused the error, empty string if no label is set, or `null` if the message has no error. Use this for more human-readable error tracking when components have custom labels.

==== Examples


```coffeescript
root.doc.error_source_label = error_source_label()
```

Route errors based on component labels.

```coffeescript
root.error_category = error_source_label().or("unknown")
```

=== `error_source_name`

Returns the component name that caused the error, or `null` if the message has no error or the error has no associated component. Use this to identify which processor or component in your pipeline caused a failure.

==== Examples


```coffeescript
root.doc.error_source_name = error_source_name()
```

Create detailed error logs with component information.

```coffeescript
root.error_details = if errored() {
  {
    "message": error(),
    "component": error_source_name(),
    "timestamp": now()
  }
}
```

=== `error_source_path`

Returns the dot-separated path to the component that caused the error, or `null` if the message has no error. Use this to identify the exact location of a failed component in nested pipeline configurations.

==== Examples


```coffeescript
root.doc.error_source_path = error_source_path()
```

Build comprehensive error context for debugging.

```coffeescript
root.error_info = {
  "path": error_source_path(),
  "component": error_source_name(),
  "message": error()
}
```

=== `errored`

Returns true if the message has failed processing, false otherwise. Use this for conditional logic in error handling workflows or to route failed messages to dead letter queues.

==== Examples


```coffeescript
root.doc.status = if errored() { 400 } else { 200 }
```

Send only failed messages to a separate stream.

```coffeescript
root = if errored() { this } else { deleted() }
```

=== `json`

Returns a field from the original JSON message by dot path, always accessing the root document regardless of mapping context. Use this to reference the source message when working in nested contexts or to extract specific fields.

==== Parameters

- *`path`* &lt;string, default `""`&gt; An optional [dot path][field_paths] identifying a field to obtain.  

==== Examples


```coffeescript
root.mapped = json("foo.bar")

# In:  {"foo":{"bar":"hello world"}}
# Out: {"mapped":"hello world"}
```

Access the original message from within nested mapping contexts.

```coffeescript
root.doc = json()

# In:  {"foo":{"bar":"hello world"}}
# Out: {"doc":{"foo":{"bar":"hello world"}}}
```

=== `metadata`

Returns metadata from the input message by key, or `null` if the key doesn't exist. This reads the original metadata; to access modified metadata during mapping, use the `@` operator instead. Use this to extract message properties like topics, headers, or timestamps.

==== Parameters

- *`key`* &lt;string, default `""`&gt; An optional key of a metadata value to obtain.  

==== Examples


```coffeescript
root.topic = metadata("kafka_topic")
```

Retrieve all metadata as an object by omitting the key parameter.

```coffeescript
root.all_metadata = metadata()
```

Copy specific metadata fields to the message body.

```coffeescript
root.source = {
  "topic": metadata("kafka_topic"),
  "partition": metadata("kafka_partition"),
  "timestamp": metadata("kafka_timestamp_unix")
}
```

=== `tracing_id`

[CAUTION]
====
This function is experimental and therefore breaking changes could be made to it outside of major version releases.
====
Returns the OpenTelemetry trace ID for the message, or an empty string if no tracing span exists. Use this to correlate logs and events with distributed traces.

==== Examples


```coffeescript
meta trace_id = tracing_id()
```

Add trace ID to structured logs.

```coffeescript
root.log_entry = this
root.log_entry.trace_id = tracing_id()
```

=== `tracing_span`

[CAUTION]
====
This function is experimental and therefore breaking changes could be made to it outside of major version releases.
====
Returns the OpenTelemetry tracing span attached to the message as a text map object, or `null` if no span exists. Use this to propagate trace context to downstream systems via headers or metadata.

==== Examples


```coffeescript
root.headers.traceparent = tracing_span().traceparent

# In:  {"some_stuff":"just can't be explained by science"}
# Out: {"headers":{"traceparent":"00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01"}}
```

Forward all tracing fields to output metadata.

```coffeescript
meta = tracing_span()
```

== Environment

=== `env`

Reads an environment variable and returns its value as a string. Returns `null` if the variable is not set. By default, values are cached for performance.

==== Parameters

- *`name`* &lt;string&gt; The name of the environment variable to read.  
- *`no_cache`* &lt;bool, default `false`&gt; Disable caching to read the latest value on each invocation.  

==== Examples


```coffeescript
root.api_key = env("API_KEY")
```

```coffeescript
root.database_url = env("DB_URL").or("localhost:5432")
```

Use `no_cache` to read updated environment variables during runtime, useful for dynamic configuration changes.

```coffeescript
root.config = env(name: "DYNAMIC_CONFIG", no_cache: true)
```

=== `file`

Reads a file and returns its contents as bytes. Paths are resolved from the process working directory. For paths relative to the mapping file, use `file_rel`. By default, files are cached after first read.

==== Parameters

- *`path`* &lt;string&gt; The absolute or relative path to the file.  
- *`no_cache`* &lt;bool, default `false`&gt; Disable caching to read the latest file contents on each invocation.  

==== Examples


```coffeescript
root.config = file("/etc/config.json").parse_json()
```

```coffeescript
root.template = file("./templates/email.html").string()
```

Use `no_cache` to read updated file contents during runtime, useful for hot-reloading configuration.

```coffeescript
root.rules = file(path: "/etc/rules.yaml", no_cache: true).parse_yaml()
```

=== `file_rel`

Reads a file and returns its contents as bytes. Paths are resolved relative to the mapping file's directory, making it portable across different environments. By default, files are cached after first read.

==== Parameters

- *`path`* &lt;string&gt; The path to the file, relative to the mapping file's directory.  
- *`no_cache`* &lt;bool, default `false`&gt; Disable caching to read the latest file contents on each invocation.  

==== Examples


```coffeescript
root.schema = file_rel("./schemas/user.json").parse_json()
```

```coffeescript
root.lookup = file_rel("../data/lookup.csv").parse_csv()
```

Use `no_cache` to read updated file contents during runtime, useful for reloading data files without restarting.

```coffeescript
root.translations = file_rel(path: "./i18n/en.yaml", no_cache: true).parse_yaml()
```

=== `hostname`

Returns the hostname of the machine running Benthos. Useful for identifying which instance processed a message in distributed deployments.

==== Examples


```coffeescript
root.processed_by = hostname()
```

=== `now`

Returns the current timestamp as an RFC 3339 formatted string with nanosecond precision. Use this to add processing timestamps to messages or measure time between events. Chain with `ts_format` to customize the format or timezone.

==== Examples


```coffeescript
root.received_at = now()
```

Format the timestamp in a custom format and timezone.

```coffeescript
root.received_at = now().ts_format("Mon Jan 2 15:04:05 -0700 MST 2006", "UTC")
```

=== `timestamp_unix`

Returns the current Unix timestamp in seconds since epoch. Use this for numeric timestamps compatible with most systems, or as a seed for random number generation.

==== Examples


```coffeescript
root.received_at = timestamp_unix()
```

Create a sortable ID combining timestamp with a counter.

```coffeescript
root.id = "%v-%v".format(timestamp_unix(), batch_index())
```

=== `timestamp_unix_micro`

Returns the current Unix timestamp in microseconds since epoch. Use this for high-precision timing measurements or when microsecond resolution is required.

==== Examples


```coffeescript
root.received_at = timestamp_unix_micro()
```

Measure elapsed time between events.

```coffeescript
root.processing_duration_us = timestamp_unix_micro() - this.start_time_us
```

=== `timestamp_unix_milli`

Returns the current Unix timestamp in milliseconds since epoch. Use this for millisecond-precision timestamps common in web APIs and JavaScript systems.

==== Examples


```coffeescript
root.received_at = timestamp_unix_milli()
```

Add processing time metadata.

```coffeescript
meta processing_time_ms = timestamp_unix_milli()
```

=== `timestamp_unix_nano`

Returns the current Unix timestamp in nanoseconds since epoch. Use this for the highest precision timing or as a unique seed value that changes on every invocation.

==== Examples


```coffeescript
root.received_at = timestamp_unix_nano()
```

Generate unique random values on each mapping.

```coffeescript
root.random_value = random_int(timestamp_unix_nano())
```

== Fake Data Generation

=== `fake`

[NOTE]
====
This function is mostly stable but breaking changes could still be made outside of major version releases if a fundamental problem with it is found.
====
Generates realistic fake data for testing and development purposes. Supports a wide variety of data types including personal information, network addresses, dates/times, financial data, and UUIDs. Useful for creating mock data, populating test databases, or anonymizing sensitive information.

Supported functions: `latitude`, `longitude`, `unix_time`, `date`, `time_string`, `month_name`, `year_string`, `day_of_week`, `day_of_month`, `timestamp`, `century`, `timezone`, `time_period`, `email`, `mac_address`, `domain_name`, `url`, `username`, `ipv4`, `ipv6`, `password`, `jwt`, `word`, `sentence`, `paragraph`, `cc_type`, `cc_number`, `currency`, `amount_with_currency`, `title_male`, `title_female`, `first_name`, `first_name_male`, `first_name_female`, `last_name`, `name`, `gender`, `chinese_first_name`, `chinese_last_name`, `chinese_name`, `phone_number`, `toll_free_phone_number`, `e164_phone_number`, `uuid_hyphenated`, `uuid_digit`.

==== Parameters

- *`function`* &lt;string, default `""`&gt; The name of the faker function to use. See description for full list of supported functions.  

==== Examples


Generate fake user profile data for testing

```coffeescript
root.user = {
  "id": fake("uuid_hyphenated"),
  "name": fake("name"),
  "email": fake("email"),
  "created_at": fake("timestamp")
}
```

Create realistic test data for network monitoring

```coffeescript
root.event = {
  "source_ip": fake("ipv4"),
  "mac_address": fake("mac_address"),
  "url": fake("url")
}
```

== Deprecated

=== `count`

The `count` function is a counter starting at 1 which increments after each time it is called. Count takes an argument which is an identifier for the counter, allowing you to specify multiple unique counters in your configuration.

==== Parameters

- *`name`* &lt;string&gt; An identifier for the counter.  

==== Examples


```coffeescript
root = this
root.id = count("bloblang_function_example")

# In:  {"message":"foo"}
# Out: {"id":1,"message":"foo"}

# In:  {"message":"bar"}
# Out: {"id":2,"message":"bar"}
```

=== `meta`

Returns the value of a metadata key from the input message as a string, or `null` if the key does not exist. Since values are extracted from the read-only input message they do NOT reflect changes made from within the map. In order to query metadata mutations made within a mapping use the <<root_meta, `root_meta` function>>. This function supports extracting metadata from other messages of a batch with the `from` method.

==== Parameters

- *`key`* &lt;string, default `""`&gt; An optional key of a metadata value to obtain.  

==== Examples


```coffeescript
root.topic = meta("kafka_topic")
```

The key parameter is optional and if omitted the entire metadata contents are returned as an object.

```coffeescript
root.all_metadata = meta()
```

=== `root_meta`

Returns the value of a metadata key from the new message being created as a string, or `null` if the key does not exist. Changes made to metadata during a mapping will be reflected by this function.

==== Parameters

- *`key`* &lt;string, default `""`&gt; An optional key of a metadata value to obtain.  

==== Examples


```coffeescript
root.topic = root_meta("kafka_topic")
```

The key parameter is optional and if omitted the entire metadata contents are returned as an object.

```coffeescript
root.all_metadata = root_meta()
```

